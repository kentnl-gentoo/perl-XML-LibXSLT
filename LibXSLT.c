/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of LibXSLT.xs. Do not edit this file, edit LibXSLT.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "LibXSLT.xs"
/* $Id: LibXSLT.xs,v 1.17 2001/04/17 16:40:06 matt Exp $ */

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <libxml/xmlversion.h>
#include <libxml/xmlmemory.h>
#include <libxml/debugXML.h>
#include <libxml/HTMLtree.h>
#include <libxslt/xslt.h>
#include <libxslt/xsltInternals.h>
#include <libxslt/transform.h>
#include <libxslt/xsltutils.h>
#include <libxslt/imports.h>
#ifdef __cplusplus
}
#endif

#define SET_CB(cb, fld) \
    RETVAL = cb ? newSVsv(cb) : &PL_sv_undef;\
    if (cb) {\
        if (cb != fld) {\
            sv_setsv(cb, fld);\
        }\
    }\
    else {\
        cb = newSVsv(fld);\
    }

SV * LibXSLT_debug_cb;

void
LibXSLT_free_all_callbacks(void)
{
    if (LibXSLT_debug_cb) {
        SvREFCNT_dec(LibXSLT_debug_cb);
    }
}

int
LibXSLT_iowrite_scalar(void * context, const char * buffer, int len)
{
    SV * scalar;
    
    scalar = (SV *)context;

    sv_catpvn(scalar, (char*)buffer, len);
    
    return len;
}

int
LibXSLT_ioclose_scalar(void * context)
{
    return 0;
}

int
LibXSLT_iowrite_fh(void * context, const char * buffer, int len)
{
    dSP;
    
    SV * ioref;
    SV * tbuff;
    SV * results;
    int cnt;
    
    ENTER;
    SAVETMPS;
    
    ioref = (SV *)context;
    
    tbuff = newSVpvn((char*)buffer, len);

    PUSHMARK(SP);
    EXTEND(SP, 2);
    PUSHs(ioref);
    PUSHs(sv_2mortal(tbuff));
    PUTBACK;
    
    cnt = perl_call_method("print", G_SCALAR);
    
    SPAGAIN;
    
    if (cnt != 1) {
        croak("fh->print() method call failed");
    }
    
    results = POPs;
    
    if (!SvOK(results)) {
        croak("print to fh failed");
    }
    
    PUTBACK;
    
    FREETMPS;
    LEAVE;
    
    return len;
}

int
LibXSLT_ioclose_fh(void * context)
{
    return 0; /* we let Perl close the FH */
}

void
LibXSLT_error_handler(void * ctxt, const char * msg, ...)
{
    va_list args;
    char buffer[50000];
    
    buffer[0] = 0;
    
    va_start(args, msg);
    vsprintf(&buffer[strlen(buffer)], msg, args);
    va_end(args);
    
    croak(buffer);
}

void
LibXSLT_debug_handler(void * ctxt, const char * msg, ...)
{
    dSP;
    
    va_list args;
    char buffer[50000];
    
    buffer[0] = 0;

    va_start(args, msg);
    vsprintf(&buffer[strlen(buffer)], msg, args);
    va_end(args);

    if (LibXSLT_debug_cb && SvTRUE(LibXSLT_debug_cb)) {
        int cnt = 0;
        SV * tbuff = newSVpv((char*)buffer, 0);
    
        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 1);
        PUSHs(tbuff);
        PUTBACK;

        cnt = perl_call_sv(LibXSLT_debug_cb, G_SCALAR);

        SPAGAIN;

        if (cnt != 1) {
            croak("debug handler call failed");
        }

        PUTBACK;

        FREETMPS;
        LEAVE;
    }
    
}

#line 179 "LibXSLT.c"
XS(XS_XML__LibXSLT_END)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::END()");
    {
#line 181 "LibXSLT.xs"
        LibXSLT_free_all_callbacks();
#line 188 "LibXSLT.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXSLT_max_depth)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::max_depth(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 187 "LibXSLT.xs"
        RETVAL = xsltMaxDepth;
        if (items > 1) {
            xsltMaxDepth = SvIV(ST(1));
        }
#line 207 "LibXSLT.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT_debug_callback)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::debug_callback(self, ...)");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 198 "LibXSLT.xs"
        if (items > 1) {
            SET_CB(LibXSLT_debug_cb, ST(1));
        }
        else {
            RETVAL = LibXSLT_debug_cb ? sv_2mortal(LibXSLT_debug_cb) : &PL_sv_undef;
        }
#line 228 "LibXSLT.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT_parse_stylesheet)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::parse_stylesheet(self, doc)");
    {
	SV *	self = ST(0);
	xmlDocPtr	doc;
#line 212 "LibXSLT.xs"
        char * CLASS = "XML::LibXSLT::Stylesheet";
#line 245 "LibXSLT.c"
	xsltStylesheetPtr	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
            doc = (xmlDocPtr)SvIV((SV*)SvRV( ST(1) ));
    else{
            warn( "XML::LibXSLT::parse_stylesheet() -- doc is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 214 "LibXSLT.xs"
        if (doc == NULL) {
            XSRETURN_UNDEF;
        }
        doc->standalone = 42;
        RETVAL = xsltParseStylesheetDoc(doc);
        if (RETVAL == NULL) {
            XSRETURN_UNDEF;
        }
#line 263 "LibXSLT.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT_parse_stylesheet_file)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::parse_stylesheet_file(self, filename)");
    {
	SV *	self = ST(0);
	const char *	filename = (const char *)SvPV(ST(1),PL_na);
#line 230 "LibXSLT.xs"
        char * CLASS = "XML::LibXSLT::Stylesheet";
#line 280 "LibXSLT.c"
	xsltStylesheetPtr	RETVAL;
#line 232 "LibXSLT.xs"
        RETVAL = xsltParseStylesheetFile(filename);
        if (RETVAL == NULL) {
            XSRETURN_UNDEF;
        }
#line 287 "LibXSLT.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT__Stylesheet_transform)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::transform(self, doc, ...)");
    {
	xsltStylesheetPtr	self;
	xmlDocPtr	doc;
#line 246 "LibXSLT.xs"
        char * CLASS = "XML::LibXML::Document";
        const char *xslt_params[255];
#line 305 "LibXSLT.c"
	xmlDocPtr	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::transform() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
            doc = (xmlDocPtr)SvIV((SV*)SvRV( ST(1) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::transform() -- doc is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 250 "LibXSLT.xs"
        if (doc == NULL) {
            XSRETURN_UNDEF;
        }
        xslt_params[0] = 0;
        if (items > 256) {
            croak("Too many parameters in transform()");
        }
        if (items % 2) {
            croak("Odd number of parameters");
        }
        if (items > 2) {
            int i;
            for (i = 2; (i < items && i < 256); i++) {
                xslt_params[i - 2] = (char *)SvPV(ST(i), PL_na);
            }
            xslt_params[i - 2] = 0;
        }
        RETVAL = xsltApplyStylesheet(self, doc, xslt_params);
        if (RETVAL == NULL) {
            XSRETURN_UNDEF;
        }
#line 343 "LibXSLT.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT__Stylesheet_transform_file)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::transform_file(self, filename, ...)");
    {
	xsltStylesheetPtr	self;
	char *	filename = (char *)SvPV(ST(1),PL_na);
#line 280 "LibXSLT.xs"
        char * CLASS = "XML::LibXML::Document";
        const char *xslt_params[255];
#line 361 "LibXSLT.c"
	xmlDocPtr	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::transform_file() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 284 "LibXSLT.xs"
        xslt_params[0] = 0;
        if (items > 256) {
            croak("Too many parameters in transform()");
        }
        if (items % 2) {
            croak("Odd number of parameters");
        }
        if (items > 2) {
            int i;
            for (i = 2; (i < items && i < 256); i++) {
                xslt_params[i - 2] = (char *)SvPV(ST(i), PL_na);
            }
            xslt_params[i - 2] = 0;
        }
        RETVAL = xsltApplyStylesheet(self, xmlParseFile(filename), xslt_params);
        if (RETVAL == NULL) {
            XSRETURN_UNDEF;
        }
#line 389 "LibXSLT.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT__Stylesheet_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::DESTROY(self)");
    {
	xsltStylesheetPtr	self;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::DESTROY() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 310 "LibXSLT.xs"
        if (self == NULL) {
            XSRETURN_UNDEF;
        }
        xsltFreeStylesheet(self);
#line 415 "LibXSLT.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXSLT__Stylesheet_output_string)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::output_string(self, doc)");
    {
	xsltStylesheetPtr	self;
	xmlDocPtr	doc;
#line 320 "LibXSLT.xs"
        xmlOutputBufferPtr output;
        SV * results = newSVpv("", 0);
        const xmlChar *encoding = NULL;
	xmlCharEncodingHandlerPtr encoder = NULL;
#line 433 "LibXSLT.c"
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_string() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
            doc = (xmlDocPtr)SvIV((SV*)SvRV( ST(1) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_string() -- doc is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 325 "LibXSLT.xs"
        XSLT_GET_IMPORT_PTR(encoding, self, encoding)
        if (encoding != NULL) {
            encoder = xmlFindCharEncodingHandler((char *)encoding);
	    if ((encoder != NULL) &&
                 (xmlStrEqual((const xmlChar *)encoder->name,
                              (const xmlChar *) "UTF-8")))
                encoder = NULL;
        }
        output = xmlOutputBufferCreateIO( 
            (xmlOutputWriteCallback) LibXSLT_iowrite_scalar,
            (xmlOutputCloseCallback) LibXSLT_ioclose_scalar,
            (void*)results,
            encoder
            );
        if (xsltSaveResultTo(output, doc, self) == -1) {
            croak("output to scalar failed");
        }
        xmlOutputBufferClose(output);
        RETVAL = results;
#line 469 "LibXSLT.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXSLT__Stylesheet_output_fh)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::output_fh(self, doc, fh)");
    {
	xsltStylesheetPtr	self;
	xmlDocPtr	doc;
	SV *	fh = ST(2);
#line 353 "LibXSLT.xs"
        xmlOutputBufferPtr output;
        const xmlChar *encoding = NULL;
	xmlCharEncodingHandlerPtr encoder = NULL;
#line 489 "LibXSLT.c"

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_fh() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
            doc = (xmlDocPtr)SvIV((SV*)SvRV( ST(1) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_fh() -- doc is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 357 "LibXSLT.xs"
        XSLT_GET_IMPORT_PTR(encoding, self, encoding)
        if (encoding != NULL) {
            encoder = xmlFindCharEncodingHandler((char *)encoding);
	    if ((encoder != NULL) &&
                 (xmlStrEqual((const xmlChar *)encoder->name,
                              (const xmlChar *) "UTF-8")))
                encoder = NULL;
        }
        output = xmlOutputBufferCreateIO( 
            (xmlOutputWriteCallback) LibXSLT_iowrite_fh,
            (xmlOutputCloseCallback) LibXSLT_ioclose_fh,
            (void*)fh,
            encoder
            );
        if (xsltSaveResultTo(output, doc, self) == -1) {
            croak("output to fh failed");
        }
        xmlOutputBufferClose(output);
#line 523 "LibXSLT.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXSLT__Stylesheet_output_file)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: XML::LibXSLT::Stylesheet::output_file(self, doc, filename)");
    {
	xsltStylesheetPtr	self;
	xmlDocPtr	doc;
	char *	filename = (char *)SvPV(ST(2),PL_na);

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xsltStylesheetPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_file() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) )
            doc = (xmlDocPtr)SvIV((SV*)SvRV( ST(1) ));
    else{
            warn( "XML::LibXSLT::Stylesheet::output_file() -- doc is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 382 "LibXSLT.xs"
        xsltSaveResultToFilename(filename, doc, self, 0);
#line 553 "LibXSLT.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XML__LibXSLT)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("XML::LibXSLT::END", XS_XML__LibXSLT_END, file);
        newXS("XML::LibXSLT::max_depth", XS_XML__LibXSLT_max_depth, file);
        newXS("XML::LibXSLT::debug_callback", XS_XML__LibXSLT_debug_callback, file);
        newXS("XML::LibXSLT::parse_stylesheet", XS_XML__LibXSLT_parse_stylesheet, file);
        newXS("XML::LibXSLT::parse_stylesheet_file", XS_XML__LibXSLT_parse_stylesheet_file, file);
        newXS("XML::LibXSLT::Stylesheet::transform", XS_XML__LibXSLT__Stylesheet_transform, file);
        newXS("XML::LibXSLT::Stylesheet::transform_file", XS_XML__LibXSLT__Stylesheet_transform_file, file);
        newXS("XML::LibXSLT::Stylesheet::DESTROY", XS_XML__LibXSLT__Stylesheet_DESTROY, file);
        newXS("XML::LibXSLT::Stylesheet::output_string", XS_XML__LibXSLT__Stylesheet_output_string, file);
        newXS("XML::LibXSLT::Stylesheet::output_fh", XS_XML__LibXSLT__Stylesheet_output_fh, file);
        newXS("XML::LibXSLT::Stylesheet::output_file", XS_XML__LibXSLT__Stylesheet_output_file, file);

    /* Initialisation Section */

#line 172 "LibXSLT.xs"
    LIBXML_TEST_VERSION
    xsltMaxDepth = 250;
    LibXSLT_debug_cb = NULL;
    xsltSetGenericErrorFunc(PerlIO_stderr(), (xmlGenericErrorFunc)LibXSLT_error_handler);
    xsltSetGenericDebugFunc(PerlIO_stderr(), (xmlGenericErrorFunc)LibXSLT_debug_handler);

#line 589 "LibXSLT.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

