/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of LibXML.xs. Do not edit this file, edit LibXML.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "LibXML.xs"
/* $Id: LibXML.xs,v 1.8 2001/04/17 16:40:07 matt Exp $ */

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#include <libxml/HTMLparser.h>
#include <libxml/HTMLtree.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <libxml/debugXML.h>
#include <libxml/xmlerror.h>
#include <libxml/xinclude.h>
#ifdef __cplusplus
}
#endif

#define BUFSIZE 32768

#ifdef VMS
extern int xmlDoValidityCheckingDefaultVal;
#define xmlDoValidityCheckingDefaultValue xmlDoValidityCheckingDefaultVal
extern int xmlSubstituteEntitiesDefaultVal;
#define xmlSubstituteEntitiesDefaultValue xmlSubstituteEntitiesDefaultVal
#else
extern int xmlDoValidityCheckingDefaultValue;
extern int xmlSubstituteEntitiesDefaultValue;
#endif
extern int xmlGetWarningsDefaultValue;
extern int xmlKeepBlanksDefaultValue;
extern int xmlLoadExtDtdDefaultValue;
extern int xmlPedanticParserDefaultValue;

#define SET_CB(cb, fld) \
    RETVAL = cb ? newSVsv(cb) : &PL_sv_undef;\
    if (cb) {\
        if (cb != fld) {\
            sv_setsv(cb, fld);\
        }\
    }\
    else {\
        cb = newSVsv(fld);\
    }

SV * LibXML_match_cb = NULL;
SV * LibXML_read_cb = NULL;
SV * LibXML_open_cb = NULL;
SV * LibXML_close_cb = NULL;
SV * LibXML_error = NULL;

void
LibXML_free_all_callbacks(void)
{
    if (LibXML_match_cb) {
        SvREFCNT_dec(LibXML_match_cb);
    }
    
    if (LibXML_read_cb) {
        SvREFCNT_dec(LibXML_read_cb);
    }
    
    if (LibXML_open_cb) {
        SvREFCNT_dec(LibXML_open_cb);
    }
    
    if (LibXML_close_cb) {
        SvREFCNT_dec(LibXML_close_cb);
    }

}

xmlParserInputPtr
LibXML_load_external_entity(
        const char * URL, 
        const char * ID, 
        xmlParserCtxtPtr ctxt)
{
    SV * self;
    HV * real_obj;
    SV ** func;
    int count;
    SV * results;
    STRLEN results_len;
    const char * results_pv;
    xmlParserInputBufferPtr input_buf;
    
    self = (SV *)ctxt->_private;
    real_obj = (HV *)SvRV(self);
    func = hv_fetch(real_obj, "ext_ent_handler", 15, 0);
    
    if (func) {
        dSP;
        
        ENTER;
        SAVETMPS;

        PUSHMARK(SP) ;
        XPUSHs(sv_2mortal(newSVpv((char*)URL, 0)));
        XPUSHs(sv_2mortal(newSVpv((char*)ID, 0)));
        PUTBACK;
        
        count = perl_call_sv(*func, G_SCALAR);
        
        SPAGAIN;
        
        if (!count) {
            croak("external entity handler did not return a value");
        }
        
        results = POPs;
        
        results_pv = SvPV(results, results_len);
        input_buf = xmlParserInputBufferCreateMem(
                        results_pv,
                        results_len,
                        XML_CHAR_ENCODING_NONE
                        );
        
        FREETMPS;
        LEAVE;
        
        return xmlNewIOInputStream(ctxt, input_buf, XML_CHAR_ENCODING_NONE);
    }
    else {
        if (URL == NULL) {
            return NULL;
        }
        return xmlNewInputFromFile(ctxt, URL);
    }
    
}

int 
LibXML_input_match(char const * filename)
{
    int results = 0;
    
    if (LibXML_match_cb && SvTRUE(LibXML_match_cb)) {
        int count;
        SV * res;

        dSP;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 1);
        PUSHs(sv_2mortal(newSVpv((char*)filename, 0)));
        PUTBACK;

        count = perl_call_sv(LibXML_match_cb, G_SCALAR);

        SPAGAIN;
        
        if (count != 1) {
            croak("match callback must return a single value");
        }
        
        res = POPs;

        if (SvTRUE(res)) {
            results = 1;
        }
        
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
    
    return results;
}

void * 
LibXML_input_open(char const * filename)
{
    SV * results;
    
    if (LibXML_open_cb && SvTRUE(LibXML_open_cb)) {
        int count;

        dSP;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 1);
        PUSHs(sv_2mortal(newSVpv((char*)filename, 0)));
        PUTBACK;

        count = perl_call_sv(LibXML_open_cb, G_SCALAR);

        SPAGAIN;
        
        if (count != 1) {
            croak("open callback must return a single value");
        }

        results = POPs;
        
        SvREFCNT_inc(results);
        
        PUTBACK;
        FREETMPS;
        LEAVE;
    }
    
    return (void *)results;
}

int 
LibXML_input_read(void * context, char * buffer, int len)
{
    SV * results = NULL;
    STRLEN res_len = 0;
    const char * output;
    
    SV * ctxt = (SV *)context;
    
    if (LibXML_read_cb && SvTRUE(LibXML_read_cb)) {
        int count;

        dSP;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 2);
        PUSHs(ctxt);
        PUSHs(sv_2mortal(newSViv(len)));
        PUTBACK;

        count = perl_call_sv(LibXML_read_cb, G_SCALAR);

        SPAGAIN;
        
        if (count != 1) {
            croak("read callback must return a single value");
        }

        output = POPp;
        if (output != NULL) {
            res_len = strlen(output);
            if (res_len) {
                strncpy(buffer, output, res_len);
            }
            else {
                buffer[0] = 0;
            }
        }
        
        FREETMPS;
        LEAVE;
    }
    
    /* warn("read, asked for: %d, returning: [%d] %s\n", len, res_len, buffer); */
    return res_len;
}

void 
LibXML_input_close(void * context)
{
    SV * ctxt = (SV *)context;
    
    if (LibXML_close_cb && SvTRUE(LibXML_close_cb)) {
        int count;

        dSP;

        ENTER;
        SAVETMPS;

        PUSHMARK(SP);
        EXTEND(SP, 1);
        PUSHs(ctxt);
        PUTBACK;

        count = perl_call_sv(LibXML_close_cb, G_SCALAR);

        SPAGAIN;

        SvREFCNT_dec(ctxt);
        
        if (!count) {
            croak("close callback failed");
        }

        PUTBACK;
        FREETMPS;
        LEAVE;
    }
}

void
LibXML_error_handler(void * ctxt, const char * msg, ...)
{
    va_list args;
    char buffer[50000];
    
    buffer[0] = 0;
    
    va_start(args, msg);
    vsprintf(&buffer[strlen(buffer)], msg, args);
    va_end(args);
    
    sv_catpv(LibXML_error, buffer);
/*    croak(buffer); */
}

void
LibXML_validity_error(void * ctxt, const char * msg, ...)
{
    va_list args;
    char buffer[50000];
    
    buffer[0] = 0;
    
    va_start(args, msg);
    vsprintf(&buffer[strlen(buffer)], msg, args);
    va_end(args);
    
    sv_catpv(LibXML_error, buffer);
/*    croak(buffer); */
}

void
LibXML_validity_warning(void * ctxt, const char * msg, ...)
{
    va_list args;
    char buffer[50000];
    
    buffer[0] = 0;
    
    va_start(args, msg);
    vsprintf(&buffer[strlen(buffer)], msg, args);
    va_end(args);
    
    warn(buffer);
}

xmlParserCtxtPtr
LibXML_get_context(SV * self)
{
    SV ** ctxt_sv;
    ctxt_sv = hv_fetch((HV *)SvRV(self), "_context", 8, 0);
    if (!ctxt_sv) {
        croak("cannot fetch context!");
    }
    return (xmlParserCtxtPtr)SvIV((SV*)SvRV(*ctxt_sv));
}

xmlDocPtr
LibXML_parse_stream(SV * self, SV * ioref)
{
    dSP;
    
    xmlDocPtr doc;
    xmlParserCtxtPtr ctxt;
    int well_formed;
    
    SV * tbuff;
    SV * tsize;
    
    int done = 0;
    
    ENTER;
    SAVETMPS;
    
    tbuff = newSV(0);
    tsize = newSViv(BUFSIZE);
    
    ctxt = LibXML_get_context(self);
    
    while (!done) {
        int cnt;
        SV * read_results;
        STRLEN read_length;
        char * chars;
        
        SAVETMPS;
        
        PUSHMARK(SP);
        EXTEND(SP, 3);
        PUSHs(ioref);
        PUSHs(tbuff);
        PUSHs(tsize);
        PUTBACK;
        
        cnt = perl_call_method("read", G_SCALAR);
        
        SPAGAIN;
        
        if (cnt != 1) {
            croak("read method call failed");
        }
        
        read_results = POPs;
        
        if (!SvOK(read_results)) {
            croak("read error");
        }
        
        read_length = SvIV(read_results);
        
        chars = SvPV(tbuff, read_length);
        
        if (read_length > 0) {
            if (read_length == BUFSIZE) {
                xmlParseChunk(ctxt, chars, read_length, 0);
            }
            else {
                xmlParseChunk(ctxt, chars, read_length, 1);
                done = 1;
            }
        }
        else {
            done = 1;
        }
        
        PUTBACK;
        
        FREETMPS;
    }
    
    doc = ctxt->myDoc;
    well_formed = ctxt->wellFormed;
    
    FREETMPS;
    LEAVE;
    
    if (!well_formed) {
        xmlFreeDoc(doc);
        return NULL;
    }
    
    return doc;
}

#line 456 "LibXML.c"
XS(XS_XML__LibXML_END)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: XML::LibXML::END()");
    {
#line 468 "LibXML.xs"
        LibXML_free_all_callbacks();
        xmlCleanupParser();
        SvREFCNT_dec(LibXML_error);
#line 467 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML_match_callback)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::match_callback(self, ...)");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 476 "LibXML.xs"
        if (items > 1) {
            SET_CB(LibXML_match_cb, ST(1));
        }
        else {
            RETVAL = LibXML_match_cb ? sv_2mortal(LibXML_match_cb) : &PL_sv_undef;
        }
#line 487 "LibXML.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_open_callback)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::open_callback(self, ...)");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 489 "LibXML.xs"
        if (items > 1) {
            SET_CB(LibXML_open_cb, ST(1));
        }
        else {
            RETVAL = LibXML_open_cb ? sv_2mortal(LibXML_open_cb) : &PL_sv_undef;
        }
#line 509 "LibXML.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_read_callback)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::read_callback(self, ...)");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 502 "LibXML.xs"
        if (items > 1) {
            SET_CB(LibXML_read_cb, ST(1));
        }
        else {
            RETVAL = LibXML_read_cb ? sv_2mortal(LibXML_read_cb) : &PL_sv_undef;
        }
#line 531 "LibXML.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_close_callback)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::close_callback(self, ...)");
    {
	SV *	self = ST(0);
	SV *	RETVAL;
#line 515 "LibXML.xs"
        if (items > 1) {
            SET_CB(LibXML_close_cb, ST(1));
        }
        else {
            RETVAL = LibXML_close_cb ? sv_2mortal(LibXML_close_cb) : &PL_sv_undef;
        }
#line 553 "LibXML.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_validation)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::validation(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 528 "LibXML.xs"
        RETVAL = xmlDoValidityCheckingDefaultValue;
        if (items > 1) {
            xmlDoValidityCheckingDefaultValue = SvTRUE(ST(1)) ? 1 : 0;
        }
#line 574 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_expand_entities)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::expand_entities(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 539 "LibXML.xs"
        RETVAL = xmlSubstituteEntitiesDefaultValue;
        if (items > 1) {
            xmlSubstituteEntitiesDefaultValue = SvTRUE(ST(1)) ? 1 : 0;
        }
#line 594 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_keep_blanks)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::keep_blanks(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 550 "LibXML.xs"
        RETVAL = xmlKeepBlanksDefaultValue;
        if (items > 1) {
            xmlKeepBlanksDefaultValue = SvTRUE(ST(1)) ? 1 : 0;
        }
#line 614 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_pedantic_parser)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::pedantic_parser(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 561 "LibXML.xs"
        RETVAL = xmlPedanticParserDefaultValue;
        if (items > 1) {
            xmlPedanticParserDefaultValue = SvTRUE(ST(1)) ? 1 : 0;
        }
#line 634 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML_load_ext_dtd)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::load_ext_dtd(self, ...)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 572 "LibXML.xs"
        RETVAL = xmlLoadExtDtdDefaultValue;
        if (items > 1) {
            xmlLoadExtDtdDefaultValue = SvTRUE(ST(1)) ? 1 : 0;
        }
#line 654 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__prepare)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::_prepare(self)");
    {
	SV *	self = ST(0);
#line 583 "LibXML.xs"
        xmlParserCtxtPtr ctxt;
        SV * ctxt_sv;
#line 670 "LibXML.c"
#line 586 "LibXML.xs"
        sv_setpvn(LibXML_error, "", 0);
        ctxt = xmlCreatePushParserCtxt(NULL, NULL, "", 0, NULL);
        ctxt->_private = (void*)self;
        ctxt_sv = NEWSV(0, 0);
        sv_setref_pv(ctxt_sv, "XML::LibXML::Context", (void*)ctxt);
        hv_store((HV *)SvRV(self), "_context", 8, ctxt_sv, 0);
#line 678 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML__release)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::_release(self)");
    {
	SV *	self = ST(0);
#line 597 "LibXML.xs"
        xmlParserCtxtPtr ctxt;
#line 692 "LibXML.c"
#line 599 "LibXML.xs"
        ctxt = (xmlParserCtxtPtr)SvIV(
                (SV*)SvRV(
                        hv_delete((HV *)SvRV(self), "_context", 8, 0)
                        )
                    );
#line 699 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML_get_last_error)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::get_last_error(CLASS)");
    {
	char *	CLASS = (char *)SvPV(ST(0),PL_na);
#line 609 "LibXML.xs"
        STRLEN len;
#line 713 "LibXML.c"
	char *	RETVAL;
	dXSTARG;
#line 611 "LibXML.xs"
        RETVAL = SvPV(LibXML_error, len);
#line 718 "LibXML.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__parse_string)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXML::_parse_string(self, string)");
    {
	SV *	self = ST(0);
	SV *	string = ST(1);
#line 620 "LibXML.xs"
        xmlParserCtxtPtr ctxt;
        char * CLASS = "XML::LibXML::Document";
        STRLEN len;
        char * ptr;
        int well_formed;
#line 738 "LibXML.c"
	xmlDocPtr	RETVAL;
#line 626 "LibXML.xs"
        ptr = SvPV(string, len);
        ctxt = LibXML_get_context(self);
        xmlParseChunk(ctxt, ptr, len, 0);
        xmlParseChunk(ctxt, ptr, 0, 1);
        well_formed = ctxt->wellFormed;
        RETVAL = ctxt->myDoc;
        if (!well_formed) {
            xmlFreeDoc(RETVAL);
            croak(SvPV(LibXML_error, len));
        }
#line 751 "LibXML.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__parse_fh)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXML::_parse_fh(self, fh)");
    {
	SV *	self = ST(0);
	SV *	fh = ST(1);
#line 644 "LibXML.xs"
        char * CLASS = "XML::LibXML::Document";
        STRLEN len;
#line 769 "LibXML.c"
	xmlDocPtr	RETVAL;
#line 647 "LibXML.xs"
        RETVAL = LibXML_parse_stream(self, fh);
        if (RETVAL == NULL) {
            croak(SvPV(LibXML_error, len));
        }
#line 776 "LibXML.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__parse_file)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: XML::LibXML::_parse_file(self, filename)");
    {
	SV *	self = ST(0);
	const char *	filename = (const char *)SvPV(ST(1),PL_na);
#line 659 "LibXML.xs"
        xmlParserCtxtPtr ctxt;
        char * CLASS = "XML::LibXML::Document";
        PerlIO *f;
        int ret;
        int res;
        STRLEN len;
        char chars[BUFSIZE];
#line 799 "LibXML.c"
	xmlDocPtr	RETVAL;
#line 667 "LibXML.xs"
        if ((filename[0] == '-') && (filename[1] == 0)) {
	    f = PerlIO_stdin();
	} else {
	    f = PerlIO_open(filename, "r");
	}
	if (f != NULL) {
            ctxt = LibXML_get_context(self);
	    res = PerlIO_read(f, chars, 4);
	    if (res > 0) {
                xmlParseChunk(ctxt, chars, res, 0);
		while ((res = PerlIO_read(f, chars, BUFSIZE)) > 0) {
		    xmlParseChunk(ctxt, chars, res, 0);
		}
                xmlParseChunk(ctxt, chars, 0, 1);
		RETVAL = ctxt->myDoc;
		ret = ctxt->wellFormed;
		if (!ret) {
                    PerlIO_close(f);
		    xmlFreeDoc(RETVAL);
		    croak(SvPV(LibXML_error, len));
		}
	    }
            PerlIO_close(f);
	}
        else {
            croak("cannot open file %s", filename);
        }
#line 829 "LibXML.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__Document_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Document::DESTROY(self)");
    {
	xmlDocPtr	self;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xmlDocPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXML::Document::DESTROY() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 704 "LibXML.xs"
        if (self == NULL) {
            XSRETURN_UNDEF;
        }
        if (self->standalone == 42) {
            XSRETURN_UNDEF;
        }
        xmlFreeDoc(self);
#line 858 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML__Document_toString)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Document::toString(self)");
    {
	xmlDocPtr	self;
#line 716 "LibXML.xs"
        xmlChar *result;
        int len;
#line 873 "LibXML.c"
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xmlDocPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXML::Document::toString() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 719 "LibXML.xs"
        xmlDocDumpMemory(self, &result, &len);
	if (result == NULL) {
	    croak("Failed to convert doc to string");
	} else {
            RETVAL = newSVpvn(result, len);
	    xmlFree(result);
	}
#line 890 "LibXML.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__Document_is_valid)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Document::is_valid(self, ...)");
    {
	xmlDocPtr	self;
#line 733 "LibXML.xs"
        xmlValidCtxt cvp;
        xmlDtdPtr dtd;
        SV * dtd_sv;
#line 908 "LibXML.c"
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xmlDocPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXML::Document::is_valid() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 737 "LibXML.xs"
        if (items > 1) {
            dtd_sv = ST(1);
            if ( sv_isobject(dtd_sv) && (SvTYPE(SvRV(dtd_sv)) == SVt_PVMG) ) {
                dtd = (xmlDtdPtr)SvIV((SV*)SvRV( dtd_sv ));
            }
            else {
                croak("is_valid: argument must be a DTD object");
            }
            cvp.userData = (void*)PerlIO_stderr();
            cvp.error = (xmlValidityErrorFunc)LibXML_validity_error;
            cvp.warning = (xmlValidityWarningFunc)LibXML_validity_warning;
            RETVAL = xmlValidateDtd(&cvp, self, dtd);
        }
        else {
            RETVAL = xmlValidateDocument(&cvp, self);
        }
#line 935 "LibXML.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_XML__LibXML__Document_process_xinclude)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Document::process_xinclude(self)");
    {
	xmlDocPtr	self;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xmlDocPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXML::Document::process_xinclude() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 760 "LibXML.xs"
        xmlXIncludeProcess(self);
#line 957 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML__Context_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Context::DESTROY(self)");
    {
	xmlParserCtxtPtr	self;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
            self = (xmlParserCtxtPtr)SvIV((SV*)SvRV( ST(0) ));
    else{
            warn( "XML::LibXML::Context::DESTROY() -- self is not a blessed SV reference" );
            XSRETURN_UNDEF;
    };
#line 769 "LibXML.xs"
        xmlFreeParserCtxt(self);
#line 978 "LibXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_XML__LibXML__Dtd_new)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: XML::LibXML::Dtd::new(CLASS, external, system)");
    {
	char *	CLASS = (char *)SvPV(ST(0),PL_na);
	char *	external = (char *)SvPV(ST(1),PL_na);
	char *	system = (char *)SvPV(ST(2),PL_na);
	xmlDtdPtr	RETVAL;
#line 779 "LibXML.xs"
        RETVAL = xmlParseDTD(external, system);
#line 995 "LibXML.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_XML__LibXML)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("XML::LibXML::END", XS_XML__LibXML_END, file);
        newXS("XML::LibXML::match_callback", XS_XML__LibXML_match_callback, file);
        newXS("XML::LibXML::open_callback", XS_XML__LibXML_open_callback, file);
        newXS("XML::LibXML::read_callback", XS_XML__LibXML_read_callback, file);
        newXS("XML::LibXML::close_callback", XS_XML__LibXML_close_callback, file);
        newXS("XML::LibXML::validation", XS_XML__LibXML_validation, file);
        newXS("XML::LibXML::expand_entities", XS_XML__LibXML_expand_entities, file);
        newXS("XML::LibXML::keep_blanks", XS_XML__LibXML_keep_blanks, file);
        newXS("XML::LibXML::pedantic_parser", XS_XML__LibXML_pedantic_parser, file);
        newXS("XML::LibXML::load_ext_dtd", XS_XML__LibXML_load_ext_dtd, file);
        newXS("XML::LibXML::_prepare", XS_XML__LibXML__prepare, file);
        newXS("XML::LibXML::_release", XS_XML__LibXML__release, file);
        newXS("XML::LibXML::get_last_error", XS_XML__LibXML_get_last_error, file);
        newXS("XML::LibXML::_parse_string", XS_XML__LibXML__parse_string, file);
        newXS("XML::LibXML::_parse_fh", XS_XML__LibXML__parse_fh, file);
        newXS("XML::LibXML::_parse_file", XS_XML__LibXML__parse_file, file);
        newXS("XML::LibXML::Document::DESTROY", XS_XML__LibXML__Document_DESTROY, file);
        newXS("XML::LibXML::Document::toString", XS_XML__LibXML__Document_toString, file);
        newXS("XML::LibXML::Document::is_valid", XS_XML__LibXML__Document_is_valid, file);
        newXS("XML::LibXML::Document::process_xinclude", XS_XML__LibXML__Document_process_xinclude, file);
        newXS("XML::LibXML::Context::DESTROY", XS_XML__LibXML__Context_DESTROY, file);
        newXS("XML::LibXML::Dtd::new", XS_XML__LibXML__Dtd_new, file);

    /* Initialisation Section */

#line 451 "LibXML.xs"
    LIBXML_TEST_VERSION
    xmlInitParser();
    xmlRegisterInputCallbacks(
            (xmlInputMatchCallback)LibXML_input_match,
            (xmlInputOpenCallback)LibXML_input_open,
            (xmlInputReadCallback)LibXML_input_read,
            (xmlInputCloseCallback)LibXML_input_close
        );
    xmlSubstituteEntitiesDefaultValue = 1;
    xmlKeepBlanksDefaultValue = 1;
    xmlSetExternalEntityLoader((xmlExternalEntityLoader)LibXML_load_external_entity);
    xmlSetGenericErrorFunc(PerlIO_stderr(), (xmlGenericErrorFunc)LibXML_error_handler);
    LibXML_error = newSVpv("", 0);

#line 1052 "LibXML.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

