.\" Automatically generated by Pod::Man version 1.15
.\" Tue Apr 17 17:51:01 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "LibXSLT 3"
.TH LibXSLT 3 "perl v5.6.1" "2001-04-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:LibXSLT \- Interface to the gnome libxslt library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::LibXSLT;
\&  use XML::LibXML;
.Ve
.Vb 2
\&  my $parser = XML::LibXML->new();
\&  my $xslt = XML::LibXSLT->new();
.Ve
.Vb 2
\&  my $source = $parser->parse_file('foo.xml');
\&  my $style_doc = $parser->parse_file('bar.xsl');
.Ve
.Vb 1
\&  my $stylesheet = $xslt->parse_stylesheet($style_doc);
.Ve
.Vb 1
\&  my $results = $stylesheet->transform($source);
.Ve
.Vb 1
\&  print $stylesheet->output_string($results);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an interface to the gnome project's libxslt. This is an
extremely good \s-1XSLT\s0 engine, highly compliant and also very fast. I have
tests showing this to be more than twice as fast as Sablotron.
.SH "OPTIONS"
.IX Header "OPTIONS"
\&\s-1XML:\s0:LibXSLT has some global options. Note that these are probably not
thread or even fork safe \- so only set them once per process. Each one
of these options can be called either as class methods, or as instance
methods. However either way you call them, it still sets global options.
.PP
Each of the option methods returns its previous value, and can be called
without a parameter to retrieve the current value.
.Sh "max_depth"
.IX Subsection "max_depth"
.Vb 1
\&  XML::LibXSLT->max_depth(1000);
.Ve
This option sets the maximum recursion depth for a stylesheet. See the
very end of section 5.4 of the \s-1XSLT\s0 specification for more details on
recursion and detecting it. If your stylesheet or \s-1XML\s0 file requires
seriously deep recursion, this is the way to set it. Default value is
250.
.Sh "debug_callback"
.IX Subsection "debug_callback"
.Vb 1
\&  XML::LibXSLT->debug_callback($subref);
.Ve
Sets a callback to be used for debug messages. If you don't set this,
debug messages will be ignored.
.SH "API"
.IX Header "API"
The following methods are available on the new \s-1XML:\s0:LibXSLT object:
.Sh "parse_stylesheet($doc)"
.IX Subsection "parse_stylesheet($doc)"
\&\f(CW\*(C`$doc\*(C'\fR here is an \s-1XML:\s0:LibXML::Document object (see the XML::LibXML manpage)
representing an \s-1XSLT\s0 file. This method will return a 
\&\s-1XML:\s0:LibXSLT::Stylesheet object, or undef on failure. If the \s-1XSLT\s0 is
invalid, an exception will be thrown, so wrap the call to 
parse_stylesheet in an eval{} block to trap this.
.Sh "parse_stylesheet_file($filename)"
.IX Subsection "parse_stylesheet_file($filename)"
Exactly the same as the above, but parses the given filename directly.
.SH "XML::LibXSLT::Stylesheet"
.IX Header "XML::LibXSLT::Stylesheet"
The main \s-1API\s0 is on the stylesheet, though it is fairly minimal.
.PP
One of the main advantages of \s-1XML:\s0:LibXSLT is that you have a generic
stylesheet object which you call the \fItransform()\fR method passing in a
document to transform. This allows you to have multiple transformations
happen with one stylesheet without requiring a reparse.
.Sh "transform(doc, \f(CW%params\fP)"
.IX Subsection "transform(doc, %params)"
.Vb 1
\&  my $results = $stylesheet->transform($doc, foo => "value);
.Ve
Transforms the passed in \s-1XML:\s0:LibXML::Document object, and returns a
new \s-1XML:\s0:LibXML::Document. Extra hash entries are used as parameters.
.Sh "transform_file(filename, \f(CW%params\fP)"
.IX Subsection "transform_file(filename, %params)"
.Vb 1
\&  my $results = $stylesheet->transform_file($filename, bar => "value");
.Ve
.Sh "output_string(result)"
.IX Subsection "output_string(result)"
Returns a scalar that is the \s-1XSLT\s0 rendering of the \s-1XML:\s0:LibXML::Document
object using the desired output format (specified in the xsl:output tag
in the stylesheet). Note that you can also call \f(CW$result\fR->toString, but
that will *always* output the document in \s-1XML\s0 format, and in \s-1UTF8\s0, which
may not be what you asked for in the xsl:output tag.
.Sh "output_fh(result, fh)"
.IX Subsection "output_fh(result, fh)"
Outputs the result to the filehandle given in \f(CW\*(C`$fh\*(C'\fR.
.Sh "output_file(result, filename)"
.IX Subsection "output_file(result, filename)"
Outputs the result to the file named in \f(CW\*(C`$filename\*(C'\fR.
.SH "BENCHMARK"
.IX Header "BENCHMARK"
Included in the distribution is a simple benchmark script, which has two
drivers \- one for LibXSLT and one for Sablotron. The benchmark requires
the testcases files from the XSLTMark distribution which you can find
at http://www.datapower.com/XSLTMark/
.PP
Put the testcases directory in the directory created by this distribution,
and then run:
.PP
.Vb 1
\&  perl benchmark.pl -h
.Ve
to get a list of options.
.PP
The benchmark requires \s-1XML:\s0:XPath at the moment, but I hope to factor that
out of the equation fairly soon. It also requires Time::HiRes, which I
could be persuaded to factor out, replacing it with Benchmark.pm, but I
haven't done so yet.
.PP
I would love to get drivers for \s-1XML::XSLT\s0 and \s-1XML:\s0:Transformiix, if you
would like to contribute them. Also if you get this running on Win32, I'd
love to get a driver for \s-1MSXSLT\s0 via \s-1OLE\s0, to see what we can do against
those Redmond boys!
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.PP
Copyright 2001, AxKit.com Ltd. All rights reserved.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1XML:\s0:LibXML
