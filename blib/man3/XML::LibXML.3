.\" Automatically generated by Pod::Man version 1.15
.\" Tue Apr 17 17:50:57 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "LibXML 3"
.TH LibXML 3 "perl v5.6.1" "2001-03-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:LibXML \- Interface to the gnome libxml2 library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use XML::LibXML;
\&  my $parser = XML::LibXML->new();
.Ve
.Vb 3
\&  my $doc = $parser->parse_string(<<'EOT');
\&  <xml/>
\&  EOT
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Currently this module doesn't actually do much but parse files and give
you back a document (\s-1DOM\s0) handle. You can't actually call \s-1DOM\s0 methods on
that document though (because I haven't written the code to do it yet!).
.SH "OPTIONS"
.IX Header "OPTIONS"
LibXML options are global (unfortunately this is a limitation of the
underlying implementation, not this interface). They can either be set
using \f(CW\*(C`$parser\->option(...)\*(C'\fR, or \f(CW\*(C`XML::LibXML\->option(...)\*(C'\fR, both
are treated in the same manner. Note that even two forked processes
will share some of the same options, so be careful out there!
.PP
Every option returns the previous value, and can be called without
parameters to get the current value.
.Sh "validation"
.IX Subsection "validation"
.Vb 1
\&  XML::LibXML->validation(1);
.Ve
Turn validation on (or off). Defaults to off.
.Sh "expand_entities"
.IX Subsection "expand_entities"
.Vb 1
\&  XML::LibXML->expand_entities(0);
.Ve
Turn entity expansion on or off, enabled by default. If entity expansion
is off, any external parsed entities in the document are left as entities.
Probably not very useful for most purposes.
.Sh "keep_blanks"
.IX Subsection "keep_blanks"
.Vb 1
\&  XML::LibXML->keep_blanks(0);
.Ve
Allows you to turn off \s-1XML:\s0:LibXML's default behaviour of maintaining
whitespace in the document.
.Sh "pedantic_parser"
.IX Subsection "pedantic_parser"
.Vb 1
\&  XML::LibXML->pedantic_parser(1);
.Ve
You can make \s-1XML:\s0:LibXML more pedantic if you want to.
.Sh "load_ext_dtd"
.IX Subsection "load_ext_dtd"
.Vb 1
\&  XML::LibXML->load_ext_dtd(1);
.Ve
Load external \s-1DTD\s0 subsets while parsing.
.Sh "match_callback"
.IX Subsection "match_callback"
.Vb 1
\&  XML::LibXML->match_callback($subref);
.Ve
Sets a \*(L"match\*(R" callback. See the section on "Input Callbacks" below.
.Sh "open_callback"
.IX Subsection "open_callback"
.Vb 1
\&  XML::LibXML->open_callback($subref);
.Ve
Sets an open callback. See the section on "Input Callbacks" below.
.Sh "read_callback"
.IX Subsection "read_callback"
.Vb 1
\&  XML::LibXML->read_callback($subref);
.Ve
Sets a read callback. See the section on "Input Callbacks" below.
.Sh "close_callback"
.IX Subsection "close_callback"
.Vb 1
\&  XML::LibXML->close_callback($subref);
.Ve
Sets a close callback. See the section on "Input Callbacks" below.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The \s-1XML:\s0:LibXML constructor, \f(CW\*(C`new()\*(C'\fR, takes the following parameters:
.Sh "ext_ent_handler"
.IX Subsection "ext_ent_handler"
.Vb 1
\&  my $parser = XML::LibXML->new(ext_ent_handler => sub { ... });
.Ve
The ext_ent_handler sub is called whenever libxml needs to load an external
parsed entity. The handler sub will be passed two parameters: a
\&\s-1URL\s0 (\s-1SYSTEM\s0 identifier) and an \s-1ID\s0 (\s-1PUBLIC\s0 identifier). It should return
a string containing the resource at the given \s-1URI\s0.
.PP
Note that you do not need to enable this \- if not supplied libxml will
get the resource either directly from the filesystem, or using an internal
http client library.
.SH "PARSING"
.IX Header "PARSING"
There are three ways to parse documents \- as a string, as a Perl filehandle,
or as a filename. The return value from each is a \s-1XML:\s0:LibXML::Document
object, which is a \s-1DOM\s0 object (although no \s-1DOM\s0 methods are implemented
yet). See the section on "XML::LibXML::Document" below for more details on the methods
available on documents.
.PP
Each of the below methods will throw an exception if the document is invalid.
To prevent this causing your program exiting, wrap the call in an eval{}
block.
.Sh "parse_string"
.IX Subsection "parse_string"
.Vb 1
\&  my $doc = $parser->parse_string($string);
.Ve
.Sh "parse_fh"
.IX Subsection "parse_fh"
.Vb 1
\&  my $doc = $parser->parse_fh($fh);
.Ve
Here, \f(CW\*(C`$fh\*(C'\fR can be an \s-1IOREF\s0, or a subclass of \s-1IO:\s0:Handle.
.Sh "parse_file"
.IX Subsection "parse_file"
.Vb 1
\&  my $doc = $parser->parse_file($filename);
.Ve
.SH "XML::LibXML::Document"
.IX Header "XML::LibXML::Document"
The objects returned above have a few methods available to them:
.if n .Sh "\f(CW""$doc\->toString""\fP"
.el .Sh "\f(CW$doc\->toString\fP"
.IX Subsection "$doc->toString"
Convert the document to a string.
.if n .Sh "\f(CW""$doc\->is_valid""\fP"
.el .Sh "\f(CW$doc\->is_valid\fP"
.IX Subsection "$doc->is_valid"
Post parse validation. Returns true if the document is valid against the
\&\s-1DTD\s0 specified in the \s-1DOCTYPE\s0 declaration
.if n .Sh "\f(CW""$doc\->is_valid($dtd)""\fP"
.el .Sh "\f(CW$doc\->is_valid($dtd)\fP"
.IX Subsection "$doc->is_valid($dtd)"
Same as the above, but allows you to pass in a \s-1DTD\s0 created from 
the section on "XML::LibXML::Dtd".
.if n .Sh "\f(CW""$doc\->process_xinclude""\fP"
.el .Sh "\f(CW$doc\->process_xinclude\fP"
.IX Subsection "$doc->process_xinclude"
Process any xinclude tags in the file.
.SH "XML::LibXML::Dtd"
.IX Header "XML::LibXML::Dtd"
This module allows you to parse and return a \s-1DTD\s0 object. It has one method
right now, \f(CW\*(C`new()\*(C'\fR.
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&  my $dtd = XML::LibXML::Dtd->new($public, $system);
.Ve
Creates a new \s-1DTD\s0 object from the public and system identifiers. It will
automatically load the objects from the filesystem, or use the input
callbacks (see the section on "Input Callbacks" below) to load the \s-1DTD\s0.
.SH "Input Callbacks"
.IX Header "Input Callbacks"
The input callbacks are used whenever LibXML has to get something \fBother
than external parsed entities\fR from somewhere. The input callbacks in LibXML
are stacked on top of the original input callbacks within the libxml library.
This means that if you decide not to use your own callbacks (see \f(CW\*(C`match()\*(C'\fR),
then you can revert to the default way of handling input. This allows, for
example, to only handle certain \s-1URI\s0 schemes.
.PP
The following callbacks are defined:
.Sh "match(uri)"
.IX Subsection "match(uri)"
If you want to handle the \s-1URI\s0, simply return a true value from this callback.
.Sh "open(uri)"
.IX Subsection "open(uri)"
Open something and return it to handle that resource.
.Sh "read(handle, bytes)"
.IX Subsection "read(handle, bytes)"
Read a certain number of bytes from the resource.
.Sh "close(handle)"
.IX Subsection "close(handle)"
Close the handle associated with the resource.
.Sh "Example"
.IX Subsection "Example"
This is a purely fictitious example that uses a MyScheme::Handler object
that responds to methods similar to an \s-1IO:\s0:Handle.
.PP
.Vb 1
\&  XML::LibXML->match_callback(\e&match_uri);
.Ve
.Vb 1
\&  XML::LibXML->open_callback(\e&open_uri);
.Ve
.Vb 1
\&  XML::LibXML->read_callback(\e&read_uri);
.Ve
.Vb 1
\&  XML::LibXML->close_callback(\e&close_uri);
.Ve
.Vb 4
\&  sub match_uri {
\&    my $uri = shift;
\&    return $uri =~ /^myscheme:/;
\&  }
.Ve
.Vb 4
\&  sub open_uri {
\&    my $uri = shift;
\&    return MyScheme::Handler->new($uri);
\&  }
.Ve
.Vb 7
\&  sub read_uri {
\&    my $handler = shift;
\&    my $length = shift;
\&    my $buffer;
\&    read($handler, $buffer, $length);
\&    return $buffer;
\&  }
.Ve
.Vb 4
\&  sub close_uri {
\&    my $handler = shift;
\&    close($handler);
\&  }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt Sergeant, matt@sergeant.org
.PP
Copyright 2001, AxKit.com Ltd. All rights reserved.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1XML:\s0:LibXSLT
